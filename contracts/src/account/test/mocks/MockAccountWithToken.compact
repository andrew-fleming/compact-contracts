// SPDX-License-Identifier: MIT

pragma language_version >= 0.18.0;

import CompactStandardLibrary;
import "../../Account" prefix Account_;
import "../../../archive/ShieldedToken" prefix ShieldedToken_;

export { ZswapCoinPublicKey, ContractAddress, Either, Maybe, CoinInfo, SendResult };
export { Account_Spend, Account_Call };
export { Account__nonce, Account__coins };

export circuit receiveCoin(coin: CoinInfo): [] {
  Account_receiveCoin(coin);
}

export circuit send(
  recipient: ZswapCoinPublicKey,
  spend: Account_Spend,
  input: Bytes<32>
): [] {
  Account_send(recipient, spend, input);
}

export circuit isValidInput(
  hash: Bytes<32>,
  input: Bytes<32>
): Bytes<32> {
  return Account_isValidInput(hash, input);
}

export pure circuit ACCOUNT_NAMESPACE(): Bytes<32> {
  return Account_ACCOUNT_NAMESPACE();
}

export pure circuit inputDomain(): Bytes<32> {
  return Account_inputDomain();

}

export pure circuit sendDomain(): Bytes<32> {
  return Account_sendDomain();
}

export pure circuit invokeDomain(): Bytes<32> {
  return Account_invokeDomain();
}

export circuit accountId(): Bytes<32> {
  return disclose(Account_accountId());
}

/**
 * ShieldedToken
 */

export {
  ShieldedToken__counter,
  ShieldedToken__nonce,
  ShieldedToken__domain
};

constructor(
  _nonce: Bytes<32>,
  _name: Maybe<Opaque<"string">>,
  _symbol: Maybe<Opaque<"string">>,
  _decimals:Uint<8>
) {
  ShieldedToken_initializer(_nonce, _name, _symbol, _decimals);
}

export circuit name(): Maybe<Opaque<"string">> {
  return ShieldedToken_name();
}

export circuit symbol(): Maybe<Opaque<"string">> {
  return ShieldedToken_symbol();
}

export circuit decimals(): Uint<8> {
  return ShieldedToken_decimals();
}

export circuit totalSupply(): Uint<64> {
  return ShieldedToken_totalSupply();
}

export circuit unsafeMint(
  recipient: Either<ZswapCoinPublicKey, ContractAddress>,
  amount: Uint<64>
): CoinInfo {
  return ShieldedToken_mint(recipient, amount);
}
